{
    "identify": "ext_keypadfr",
    "version": "0.0.1",
    "device": false,
    "template": "arduinoc",
    "codeTypes": [
        "arduinoc"
    ],
    "generator": {
        "arduinoc": {
            "template": "// generated by mBlock5 for <your product>\n// codes make you happy\n\n//( include //)\n#include <Arduino.h>\n//( lib //)\n\n//({\n    this.$ALL_VARIABLES.length==0?'':this.$ALL_VARIABLES.map(v=>\"float \"+v+\" = 0;\").join('\\\\n')\n}//)\n\n//( declare //)\n\n\nvoid _delay(float seconds) {\n  long endTime = millis() + seconds * 1000;\n  while(millis() < endTime) _loop();\n}\n\n//(\nvoid setup() {\n  //( setup //)\n  //( code //)\n}\n//)\n\nvoid _loop() {\n  //( loop //)\n}\n\nvoid loop() {\n  _loop();\n}",
            "generator": "({\n  lang: 'arduinoc',\n  template: `<%=template%>`,\n  splitor: {\n    frame: {\n      left: \"//(\",\n      right: \"//)\",\n    },\n    expression: {\n      left: \"/*{\",\n      right: \"}*/\",\n    }\n  },\n  reducers: [\n    {\n      name: 'include',\n      reduce: (codes) => {\n        let codes1 = []\n        for (let code of codes) {\n          let codeStr = '';\n          if (typeof code === 'string') {\n            codeStr = code;\n          } else if (typeof code === 'function') {\n            codeStr = code();\n          }\n          if (codes1.indexOf(codeStr) === -1) {\n            codes1.push(codeStr);\n          }\n        }\n        if (codes1.length === 0) {\n          return undefined;\n        }\n        return codes1.map(code => {\n          return '#include ' + code;\n        }).join('\\n') + '\\n'\n      }\n    }\n  ]\n})",
            "snippets": "",
            "sources": [
                {
                    "name": "Keypad-3.1.1/src/Key.cpp",
                    "url": "Keypad-3.1.1/src/Key.cpp",
                    "fileData": "/*\n|| @file Key.cpp\n|| @version 1.0\n|| @author Mark Stanley\n|| @contact mstanley@technologist.com\n||\n|| @description\n|| | Key class provides an abstract definition of a key or button\n|| | and was initially designed to be used in conjunction with a\n|| | state-machine.\n|| #\n||\n|| @license\n|| | This library is free software; you can redistribute it and/or\n|| | modify it under the terms of the GNU Lesser General Public\n|| | License as published by the Free Software Foundation; version\n|| | 2.1 of the License.\n|| |\n|| | This library is distributed in the hope that it will be useful,\n|| | but WITHOUT ANY WARRANTY; without even the implied warranty of\n|| | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n|| | Lesser General Public License for more details.\n|| |\n|| | You should have received a copy of the GNU Lesser General Public\n|| | License along with this library; if not, write to the Free Software\n|| | Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n|| #\n||\n*/\n#include <Key.h>\n\n\n// default constructor\nKey::Key() {\n\tkchar = NO_KEY;\n\tkstate = IDLE;\n\tstateChanged = false;\n}\n\n// constructor\nKey::Key(char userKeyChar) {\n\tkchar = userKeyChar;\n\tkcode = -1;\n\tkstate = IDLE;\n\tstateChanged = false;\n}\n\n\nvoid Key::key_update (char userKeyChar, KeyState userState, boolean userStatus) {\n\tkchar = userKeyChar;\n\tkstate = userState;\n\tstateChanged = userStatus;\n}\n\n\n\n/*\n|| @changelog\n|| | 1.0 2012-06-04 - Mark Stanley : Initial Release\n|| #\n*/\n"
                },
                {
                    "name": "Keypad-3.1.1/src/Key.h",
                    "url": "Keypad-3.1.1/src/Key.h",
                    "fileData": "/*\n||\n|| @file Key.h\n|| @version 1.0\n|| @author Mark Stanley\n|| @contact mstanley@technologist.com\n||\n|| @description\n|| | Key class provides an abstract definition of a key or button\n|| | and was initially designed to be used in conjunction with a\n|| | state-machine.\n|| #\n||\n|| @license\n|| | This library is free software; you can redistribute it and/or\n|| | modify it under the terms of the GNU Lesser General Public\n|| | License as published by the Free Software Foundation; version\n|| | 2.1 of the License.\n|| |\n|| | This library is distributed in the hope that it will be useful,\n|| | but WITHOUT ANY WARRANTY; without even the implied warranty of\n|| | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n|| | Lesser General Public License for more details.\n|| |\n|| | You should have received a copy of the GNU Lesser General Public\n|| | License along with this library; if not, write to the Free Software\n|| | Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n|| #\n||\n*/\n\n#ifndef Keypadlib_KEY_H_\n#define Keypadlib_KEY_H_\n\n#include <Arduino.h>\n\n#define OPEN LOW\n#define CLOSED HIGH\n\ntypedef unsigned int uint;\ntypedef enum{ IDLE, PRESSED, HOLD, RELEASED } KeyState;\n\nconst char NO_KEY = '\\0';\n\nclass Key {\npublic:\n\t// members\n\tchar kchar;\n\tint kcode;\n\tKeyState kstate;\n\tboolean stateChanged;\n\n\t// methods\n\tKey();\n\tKey(char userKeyChar);\n\tvoid key_update(char userKeyChar, KeyState userState, boolean userStatus);\n\nprivate:\n\n};\n\n#endif\n\n/*\n|| @changelog\n|| | 1.0 2012-06-04 - Mark Stanley : Initial Release\n|| #\n*/\n"
                },
                {
                    "name": "Keypad-3.1.1/src/Keypad.cpp",
                    "url": "Keypad-3.1.1/src/Keypad.cpp",
                    "fileData": "/*\n||\n|| @file Keypad.cpp\n|| @version 3.1\n|| @author Mark Stanley, Alexander Brevig\n|| @contact mstanley@technologist.com, alexanderbrevig@gmail.com\n||\n|| @description\n|| | This library provides a simple interface for using matrix\n|| | keypads. It supports multiple keypresses while maintaining\n|| | backwards compatibility with the old single key library.\n|| | It also supports user selectable pins and definable keymaps.\n|| #\n||\n|| @license\n|| | This library is free software; you can redistribute it and/or\n|| | modify it under the terms of the GNU Lesser General Public\n|| | License as published by the Free Software Foundation; version\n|| | 2.1 of the License.\n|| |\n|| | This library is distributed in the hope that it will be useful,\n|| | but WITHOUT ANY WARRANTY; without even the implied warranty of\n|| | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n|| | Lesser General Public License for more details.\n|| |\n|| | You should have received a copy of the GNU Lesser General Public\n|| | License along with this library; if not, write to the Free Software\n|| | Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n|| #\n||\n*/\n#include <Keypad.h>\n\n// <<constructor>> Allows custom keymap, pin configuration, and keypad sizes.\nKeypad::Keypad(char *userKeymap, byte *row, byte *col, byte numRows, byte numCols) {\n\trowPins = row;\n\tcolumnPins = col;\n\tsizeKpd.rows = numRows;\n\tsizeKpd.columns = numCols;\n\n\tbegin(userKeymap);\n\n\tsetDebounceTime(10);\n\tsetHoldTime(500);\n\tkeypadEventListener = 0;\n\n\tstartTime = 0;\n\tsingle_key = false;\n}\n\n// Let the user define a keymap - assume the same row/column count as defined in constructor\nvoid Keypad::begin(char *userKeymap) {\n    keymap = userKeymap;\n}\n\n// Returns a single key only. Retained for backwards compatibility.\nchar Keypad::getKey() {\n\tsingle_key = true;\n\n\tif (getKeys() && key[0].stateChanged && (key[0].kstate==PRESSED))\n\t\treturn key[0].kchar;\n\t\n\tsingle_key = false;\n\n\treturn NO_KEY;\n}\n\n// Populate the key list.\nbool Keypad::getKeys() {\n\tbool keyActivity = false;\n\n\t// Limit how often the keypad is scanned. This makes the loop() run 10 times as fast.\n\tif ( (millis()-startTime)>debounceTime ) {\n\t\tscanKeys();\n\t\tkeyActivity = updateList();\n\t\tstartTime = millis();\n\t}\n\n\treturn keyActivity;\n}\n\n// Private : Hardware scan\nvoid Keypad::scanKeys() {\n\t// Re-intialize the row pins. Allows sharing these pins with other hardware.\n\tfor (byte r=0; r<sizeKpd.rows; r++) {\n\t\tpin_mode(rowPins[r],INPUT_PULLUP);\n\t}\n\n\t// bitMap stores ALL the keys that are being pressed.\n\tfor (byte c=0; c<sizeKpd.columns; c++) {\n\t\tpin_mode(columnPins[c],OUTPUT);\n\t\tpin_write(columnPins[c], LOW);\t// Begin column pulse output.\n\t\tfor (byte r=0; r<sizeKpd.rows; r++) {\n\t\t\tbitWrite(bitMap[r], c, !pin_read(rowPins[r]));  // keypress is active low so invert to high.\n\t\t}\n\t\t// Set pin to high impedance input. Effectively ends column pulse.\n\t\tpin_write(columnPins[c],HIGH);\n\t\tpin_mode(columnPins[c],INPUT);\n\t}\n}\n\n// Manage the list without rearranging the keys. Returns true if any keys on the list changed state.\nbool Keypad::updateList() {\n\n\tbool anyActivity = false;\n\n\t// Delete any IDLE keys\n\tfor (byte i=0; i<LIST_MAX; i++) {\n\t\tif (key[i].kstate==IDLE) {\n\t\t\tkey[i].kchar = NO_KEY;\n\t\t\tkey[i].kcode = -1;\n\t\t\tkey[i].stateChanged = false;\n\t\t}\n\t}\n\n\t// Add new keys to empty slots in the key list.\n\tfor (byte r=0; r<sizeKpd.rows; r++) {\n\t\tfor (byte c=0; c<sizeKpd.columns; c++) {\n\t\t\tboolean button = bitRead(bitMap[r],c);\n\t\t\tchar keyChar = keymap[r * sizeKpd.columns + c];\n\t\t\tint keyCode = r * sizeKpd.columns + c;\n\t\t\tint idx = findInList (keyCode);\n\t\t\t// Key is already on the list so set its next state.\n\t\t\tif (idx > -1)\t{\n\t\t\t\tnextKeyState(idx, button);\n\t\t\t}\n\t\t\t// Key is NOT on the list so add it.\n\t\t\tif ((idx == -1) && button) {\n\t\t\t\tfor (byte i=0; i<LIST_MAX; i++) {\n\t\t\t\t\tif (key[i].kchar==NO_KEY) {\t\t// Find an empty slot or don't add key to list.\n\t\t\t\t\t\tkey[i].kchar = keyChar;\n\t\t\t\t\t\tkey[i].kcode = keyCode;\n\t\t\t\t\t\tkey[i].kstate = IDLE;\t\t// Keys NOT on the list have an initial state of IDLE.\n\t\t\t\t\t\tnextKeyState (i, button);\n\t\t\t\t\t\tbreak;\t// Don't fill all the empty slots with the same key.\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Report if the user changed the state of any key.\n\tfor (byte i=0; i<LIST_MAX; i++) {\n\t\tif (key[i].stateChanged) anyActivity = true;\n\t}\n\n\treturn anyActivity;\n}\n\n// Private\n// This function is a state machine but is also used for debouncing the keys.\nvoid Keypad::nextKeyState(byte idx, boolean button) {\n\tkey[idx].stateChanged = false;\n\n\tswitch (key[idx].kstate) {\n\t\tcase IDLE:\n\t\t\tif (button==CLOSED) {\n\t\t\t\ttransitionTo (idx, PRESSED);\n\t\t\t\tholdTimer = millis(); }\t\t// Get ready for next HOLD state.\n\t\t\tbreak;\n\t\tcase PRESSED:\n\t\t\tif ((millis()-holdTimer)>holdTime)\t// Waiting for a key HOLD...\n\t\t\t\ttransitionTo (idx, HOLD);\n\t\t\telse if (button==OPEN)\t\t\t\t// or for a key to be RELEASED.\n\t\t\t\ttransitionTo (idx, RELEASED);\n\t\t\tbreak;\n\t\tcase HOLD:\n\t\t\tif (button==OPEN)\n\t\t\t\ttransitionTo (idx, RELEASED);\n\t\t\tbreak;\n\t\tcase RELEASED:\n\t\t\ttransitionTo (idx, IDLE);\n\t\t\tbreak;\n\t}\n}\n\n// New in 2.1\nbool Keypad::isPressed(char keyChar) {\n\tfor (byte i=0; i<LIST_MAX; i++) {\n\t\tif ( key[i].kchar == keyChar ) {\n\t\t\tif ( (key[i].kstate == PRESSED) && key[i].stateChanged )\n\t\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\t// Not pressed.\n}\n\n// Search by character for a key in the list of active keys.\n// Returns -1 if not found or the index into the list of active keys.\nint Keypad::findInList (char keyChar) {\n\tfor (byte i=0; i<LIST_MAX; i++) {\n\t\tif (key[i].kchar == keyChar) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\n// Search by code for a key in the list of active keys.\n// Returns -1 if not found or the index into the list of active keys.\nint Keypad::findInList (int keyCode) {\n\tfor (byte i=0; i<LIST_MAX; i++) {\n\t\tif (key[i].kcode == keyCode) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\n// New in 2.0\nchar Keypad::waitForKey() {\n\tchar waitKey = NO_KEY;\n\twhile( (waitKey = getKey()) == NO_KEY );\t// Block everything while waiting for a keypress.\n\treturn waitKey;\n}\n\n// Backwards compatibility function.\nKeyState Keypad::getState() {\n\treturn key[0].kstate;\n}\n\n// The end user can test for any changes in state before deciding\n// if any variables, etc. needs to be updated in their code.\nbool Keypad::keyStateChanged() {\n\treturn key[0].stateChanged;\n}\n\n// The number of keys on the key list, key[LIST_MAX], equals the number\n// of bytes in the key list divided by the number of bytes in a Key object.\nbyte Keypad::numKeys() {\n\treturn sizeof(key)/sizeof(Key);\n}\n\n// Minimum debounceTime is 1 mS. Any lower *will* slow down the loop().\nvoid Keypad::setDebounceTime(uint debounce) {\n\tdebounce<1 ? debounceTime=1 : debounceTime=debounce;\n}\n\nvoid Keypad::setHoldTime(uint hold) {\n    holdTime = hold;\n}\n\nvoid Keypad::addEventListener(void (*listener)(char)){\n\tkeypadEventListener = listener;\n}\n\nvoid Keypad::transitionTo(byte idx, KeyState nextState) {\n\tkey[idx].kstate = nextState;\n\tkey[idx].stateChanged = true;\n\n\t// Sketch used the getKey() function.\n\t// Calls keypadEventListener only when the first key in slot 0 changes state.\n\tif (single_key)  {\n\t  \tif ( (keypadEventListener!=NULL) && (idx==0) )  {\n\t\t\tkeypadEventListener(key[0].kchar);\n\t\t}\n\t}\n\t// Sketch used the getKeys() function.\n\t// Calls keypadEventListener on any key that changes state.\n\telse {\n\t  \tif (keypadEventListener!=NULL)  {\n\t\t\tkeypadEventListener(key[idx].kchar);\n\t\t}\n\t}\n}\n\n/*\n|| @changelog\n|| | 3.1 2013-01-15 - Mark Stanley     : Fixed missing RELEASED & IDLE status when using a single key.\n|| | 3.0 2012-07-12 - Mark Stanley     : Made library multi-keypress by default. (Backwards compatible)\n|| | 3.0 2012-07-12 - Mark Stanley     : Modified pin functions to support Keypad_I2C\n|| | 3.0 2012-07-12 - Stanley & Young  : Removed static variables. Fix for multiple keypad objects.\n|| | 3.0 2012-07-12 - Mark Stanley     : Fixed bug that caused shorted pins when pressing multiple keys.\n|| | 2.0 2011-12-29 - Mark Stanley     : Added waitForKey().\n|| | 2.0 2011-12-23 - Mark Stanley     : Added the public function keyStateChanged().\n|| | 2.0 2011-12-23 - Mark Stanley     : Added the private function scanKeys().\n|| | 2.0 2011-12-23 - Mark Stanley     : Moved the Finite State Machine into the function getKeyState().\n|| | 2.0 2011-12-23 - Mark Stanley     : Removed the member variable lastUdate. Not needed after rewrite.\n|| | 1.8 2011-11-21 - Mark Stanley     : Added decision logic to compile WProgram.h or Arduino.h\n|| | 1.8 2009-07-08 - Alexander Brevig : No longer uses arrays\n|| | 1.7 2009-06-18 - Alexander Brevig : Every time a state changes the keypadEventListener will trigger, if set.\n|| | 1.7 2009-06-18 - Alexander Brevig : Added setDebounceTime. setHoldTime specifies the amount of\n|| |                                          microseconds before a HOLD state triggers\n|| | 1.7 2009-06-18 - Alexander Brevig : Added transitionTo\n|| | 1.6 2009-06-15 - Alexander Brevig : Added getState() and state variable\n|| | 1.5 2009-05-19 - Alexander Brevig : Added setHoldTime()\n|| | 1.4 2009-05-15 - Alexander Brevig : Added addEventListener\n|| | 1.3 2009-05-12 - Alexander Brevig : Added lastUdate, in order to do simple debouncing\n|| | 1.2 2009-05-09 - Alexander Brevig : Changed getKey()\n|| | 1.1 2009-04-28 - Alexander Brevig : Modified API, and made variables private\n|| | 1.0 2007-XX-XX - Mark Stanley : Initial Release\n|| #\n*/\n"
                },
                {
                    "name": "Keypad-3.1.1/src/Keypad.h",
                    "url": "Keypad-3.1.1/src/Keypad.h",
                    "fileData": "/*\n||\n|| @file Keypad.h\n|| @version 3.1\n|| @author Mark Stanley, Alexander Brevig\n|| @contact mstanley@technologist.com, alexanderbrevig@gmail.com\n||\n|| @description\n|| | This library provides a simple interface for using matrix\n|| | keypads. It supports multiple keypresses while maintaining\n|| | backwards compatibility with the old single key library.\n|| | It also supports user selectable pins and definable keymaps.\n|| #\n||\n|| @license\n|| | This library is free software; you can redistribute it and/or\n|| | modify it under the terms of the GNU Lesser General Public\n|| | License as published by the Free Software Foundation; version\n|| | 2.1 of the License.\n|| |\n|| | This library is distributed in the hope that it will be useful,\n|| | but WITHOUT ANY WARRANTY; without even the implied warranty of\n|| | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n|| | Lesser General Public License for more details.\n|| |\n|| | You should have received a copy of the GNU Lesser General Public\n|| | License along with this library; if not, write to the Free Software\n|| | Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n|| #\n||\n*/\n\n#ifndef KEYPAD_H\n#define KEYPAD_H\n\n#include \"Key.h\"\n\n// bperrybap - Thanks for a well reasoned argument and the following macro(s).\n// See http://arduino.cc/forum/index.php/topic,142041.msg1069480.html#msg1069480\n#ifndef INPUT_PULLUP\n#warning \"Using  pinMode() INPUT_PULLUP AVR emulation\"\n#define INPUT_PULLUP 0x2\n#define pinMode(_pin, _mode) _mypinMode(_pin, _mode)\n#define _mypinMode(_pin, _mode)  \\\ndo {\t\t\t\t\t\t\t \\\n\tif(_mode == INPUT_PULLUP)\t \\\n\t\tpinMode(_pin, INPUT);\t \\\n\t\tdigitalWrite(_pin, 1);\t \\\n\tif(_mode != INPUT_PULLUP)\t \\\n\t\tpinMode(_pin, _mode);\t \\\n}while(0)\n#endif\n\n\n#define OPEN LOW\n#define CLOSED HIGH\n\ntypedef char KeypadEvent;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\n\n// Made changes according to this post http://arduino.cc/forum/index.php?topic=58337.0\n// by Nick Gammon. Thanks for the input Nick. It actually saved 78 bytes for me. :)\ntypedef struct {\n    byte rows;\n    byte columns;\n} KeypadSize;\n\n#define LIST_MAX 10\t\t// Max number of keys on the active list.\n#define MAPSIZE 10\t\t// MAPSIZE is the number of rows (times 16 columns)\n#define makeKeymap(x) ((char*)x)\n\n\n//class Keypad : public Key, public HAL_obj {\nclass Keypad : public Key {\npublic:\n\n\tKeypad(char *userKeymap, byte *row, byte *col, byte numRows, byte numCols);\n\n\tvirtual void pin_mode(byte pinNum, byte mode) { pinMode(pinNum, mode); }\n\tvirtual void pin_write(byte pinNum, boolean level) { digitalWrite(pinNum, level); }\n\tvirtual int  pin_read(byte pinNum) { return digitalRead(pinNum); }\n\n\tuint bitMap[MAPSIZE];\t// 10 row x 16 column array of bits. Except Due which has 32 columns.\n\tKey key[LIST_MAX];\n\tunsigned long holdTimer;\n\n\tchar getKey();\n\tbool getKeys();\n\tKeyState getState();\n\tvoid begin(char *userKeymap);\n\tbool isPressed(char keyChar);\n\tvoid setDebounceTime(uint);\n\tvoid setHoldTime(uint);\n\tvoid addEventListener(void (*listener)(char));\n\tint findInList(char keyChar);\n\tint findInList(int keyCode);\n\tchar waitForKey();\n\tbool keyStateChanged();\n\tbyte numKeys();\n\nprivate:\n\tunsigned long startTime;\n\tchar *keymap;\n    byte *rowPins;\n    byte *columnPins;\n\tKeypadSize sizeKpd;\n\tuint debounceTime;\n\tuint holdTime;\n\tbool single_key;\n\n\tvoid scanKeys();\n\tbool updateList();\n\tvoid nextKeyState(byte n, boolean button);\n\tvoid transitionTo(byte n, KeyState nextState);\n\tvoid (*keypadEventListener)(char);\n};\n\n#endif\n\n/*\n|| @changelog\n|| | 3.1 2013-01-15 - Mark Stanley     : Fixed missing RELEASED & IDLE status when using a single key.\n|| | 3.0 2012-07-12 - Mark Stanley     : Made library multi-keypress by default. (Backwards compatible)\n|| | 3.0 2012-07-12 - Mark Stanley     : Modified pin functions to support Keypad_I2C\n|| | 3.0 2012-07-12 - Stanley & Young  : Removed static variables. Fix for multiple keypad objects.\n|| | 3.0 2012-07-12 - Mark Stanley     : Fixed bug that caused shorted pins when pressing multiple keys.\n|| | 2.0 2011-12-29 - Mark Stanley     : Added waitForKey().\n|| | 2.0 2011-12-23 - Mark Stanley     : Added the public function keyStateChanged().\n|| | 2.0 2011-12-23 - Mark Stanley     : Added the private function scanKeys().\n|| | 2.0 2011-12-23 - Mark Stanley     : Moved the Finite State Machine into the function getKeyState().\n|| | 2.0 2011-12-23 - Mark Stanley     : Removed the member variable lastUdate. Not needed after rewrite.\n|| | 1.8 2011-11-21 - Mark Stanley     : Added test to determine which header file to compile,\n|| |                                          WProgram.h or Arduino.h.\n|| | 1.8 2009-07-08 - Alexander Brevig : No longer uses arrays\n|| | 1.7 2009-06-18 - Alexander Brevig : This library is a Finite State Machine every time a state changes\n|| |                                          the keypadEventListener will trigger, if set\n|| | 1.7 2009-06-18 - Alexander Brevig : Added setDebounceTime setHoldTime specifies the amount of\n|| |                                          microseconds before a HOLD state triggers\n|| | 1.7 2009-06-18 - Alexander Brevig : Added transitionTo\n|| | 1.6 2009-06-15 - Alexander Brevig : Added getState() and state variable\n|| | 1.5 2009-05-19 - Alexander Brevig : Added setHoldTime()\n|| | 1.4 2009-05-15 - Alexander Brevig : Added addEventListener\n|| | 1.3 2009-05-12 - Alexander Brevig : Added lastUdate, in order to do simple debouncing\n|| | 1.2 2009-05-09 - Alexander Brevig : Changed getKey()\n|| | 1.1 2009-04-28 - Alexander Brevig : Modified API, and made variables private\n|| | 1.0 2007-XX-XX - Mark Stanley : Initial Release\n|| #\n*/\n"
                }
            ]
        }
    },
    "platform": [
        "mblockpc",
        "mblockweb"
    ],
    "extApiVersion": [
        "1.0.0",
        "1.0.1",
        "1.0.2"
    ],
    "name": "Keypad_FR",
    "targets": [
        "arduino_lala",
        "arduino_leonardo",
        "arduino_mega",
        "arduino_mega2560",
        "arduino_mega_mechatronics",
        "arduino_micro",
        "arduino_nano",
        "arduino_nano_old",
        "arduino_rich",
        "arduino_uno",
        "arduino_uno_chao",
        "arduino_uno_goco",
        "arduino_uno_goco_blynk",
        "arduino_uno_lcd_dht11_ir_relay_sheild",
        "arduino_uno_mechatronics",
        "arduino_uno_omrs",
        "arduino_uno_r3",
        "arduino_yun",
        "rp_arduino_uno",
        "thd_arduino_uno"
    ],
    "id": "24567",
    "sort": 999,
    "description": "",
    "homepage": "http://www.mblock.cc/api-docs/_preview/mblock-5/zh/use-extensions/use-extensions.html",
    "cover": {
        "name": "cover.jpg",
        "url": "https://mblock-expanded.oss-cn-shenzhen.aliyuncs.com/07fd3ef007774bff8d0562633befd5bb.jpg"
    },
    "sourceFiles": "",
    "code": "// enter your javascript code here\n",
    "handler": "\nconst ExtHandler = {\n\n    // 当扩展加载\n    onLoad(app, target) {\n    },\n\n    // 当扩展卸载\n    onUnload(app) {\n        // TODO\n    },\n\n    // 当设备连接\n    onConnect(app, device) {\n        // TODO\n    },\n\n    // 当设备断连\n    onDisconnect(app, device) {\n        // TODO\n    },\n\n    // 当点击停止按钮\n    onStopAll(app, device) {\n        // TODO\n    },\n\n    // 当准备切换到上传模式\n    beforeChangeUploadMode(app, device) {\n        // TODO\n        return true;\n    },\n\n    // 当准备切换到调试模式\n    beforeChangeDebugMode(app, device) {\n        // TODO\n        return true;\n    },\n\n    // 当已切换到上传模式\n    afterChangeUploadMode(app, device) {\n        // TODO\n        return true;\n    },\n\n    // 当已切换到调试模式\n    afterChangeDebugMode(app, device) {\n        // TODO\n        return true;\n    },\n\n    // 当选中设备\n    onSelect(app, device) {\n        // TODO\n    },\n\n    // 当离开设备\n    onUnselect(app, device) {\n        // TODO\n    },\n\n    // 当上传代码\n    beforeCodeUpload(app, device) {\n        // TODO\n    },\n\n    // 当上传代码结束\n    afterCodeUpload(app, device) {\n        // TODO\n    },\n\n    // 当收到字节流\n    onRead(app, device) {\n        // TODO\n    }\n}\n"
}